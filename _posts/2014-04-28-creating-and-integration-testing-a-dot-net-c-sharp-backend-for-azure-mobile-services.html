---
layout: post
title: Creating and integration testing a .NET / C# Backend for Azure Mobile Services
categories:
- Azure
- General C#
tags: []
status: publish
type: post
published: true
meta:
  _edit_last: '1'
  ac_featured_article: ''
  ac_show_post_thumbnail: ''
  _wp_old_slug: integration-testing-a-dot-net-c-sharp-backend-for-azure-mobile-services
author:
  login: admin
  email: matt@mdavies.net
  display_name: Matt
  first_name: ''
  last_name: ''
---
<p>I've been experimenting with the new .NET backend for Azure Mobile Services, and for various reasons decided I'd get the highest business value from testing the backend API controllers at a high level rather than unit testing them. This proved to be a little tricky as there isn't a lot of documentation out there on the .NET backend yet, so I'll cover the steps I took to get it working with a quick walkthrough.</p>
<h2>Creating the backend</h2>
<p>Firstly, let's create a new mobile service and grab the sample app generated by the portal.</p>
<p><img class="alignnone size-full wp-image-992" src="{{ site.baseurl }}assets/img_535d227e42da9.png" alt="" /></p>
<p><img class="alignnone size-full wp-image-993" src="{{ site.baseurl }}assets/img_535d232593c17.png" alt="" /></p>
<p><img class="alignnone size-full wp-image-994" src="{{ site.baseurl }}assets/img_535d23655347b.png" alt="" /></p>
<p>Open up the sample app in Visual Studio. You should give it a test run at this point to make sure it all works correctly.</p>
<h2>Testing an API method</h2>
<p><img class="alignnone size-full wp-image-995" src="{{ site.baseurl }}assets/img_535d23b44fac8.png" alt="" /></p>
<p>All looking good? Awesome. Add a .NET 4.5+ class library for your tests and set up the unit testing framework of your choice. You'll also need to install the <code>WindowsAzure.MobileServices.Backend.Entity</code> NuGet package into your tests project.</p>
<p>While you're there, add a connection string to the app.config in your tests project by copying in the one from web.config and changing the file and initial catalog names. This will be used for our test database.</p>
<p><img class="alignnone  wp-image-997" src="{{ site.baseurl }}assets/img_535d261a74527.png" alt="" width="671" height="348" /></p>
<p>Let's see what happens when we add a really simple test:</p>
<p><script src="https://gist.github.com/MattDavies/11350785.js"></script></p>
<p><img class="alignnone size-full wp-image-1002" src="{{ site.baseurl }}assets/img_535d3a6ce2d6f.png" alt="" /></p>
<p>Cool, wouldn't have been any fun if it was that easy. If you take a look at the <code>TodoItemController</code> you'll notice some dependencies configured in the Initialize method, which isn't called by our test. We'll match that with a fake implementation in our test setup method - we can add further information to the Request and Services objects if necessary for more complex tests. You'll notice I've also chosen to manually configure the DataDirectory used in the test connection string (something that ASP.NET does automatically for our normal requests) so that the test database is created correctly under bin\Debug.</p>
<p><script src="https://gist.github.com/MattDavies/11350793.js"></script></p>
<p>With that in place, let's give our basic test another run.</p>
<p><img class="alignnone size-full wp-image-1001" src="{{ site.baseurl }}assets/img_535d32fc5a5cd.png" alt="" /></p>
<h2>Troubleshooting</h2>
<p>I'm certainly no expert on the .NET Mobile Services backend, so I'm sure I've missed things in the above steps for more complex scenarios. As I explore more, I'll update the walkthrough and add potential issues below for advanced readers.</p>
<p>1. If you use |DataDirectory| in your test connection string but don't set this up, you'll see an error like this:</p>
<p><code>System.Data.SqlClient.SqlException<br />
A file activation error occurred. The physical file name '\{databasename}.mdf' may be incorrect. Diagnose and correct additional errors, and retry the operation.<br />
CREATE DATABASE failed. Some file names listed could not be created. Check related errors.</code></p>
<p>2. If whatever reason your version doesn't include these two calls, you might face errors like these:</p>
<p><code>System.Data.SqlClient.SqlException: Cannot create more than one clustered index on table 'dbo.TodoItems'. Drop the existing clustered index 'PK_dbo.TodoItems' before creating another.</code></p>
<p><code>Validation failed for one or more entities. See 'EntityValidationErrors' property for more details.</code> errors complaining about your <code>Id</code> or <code>CreatedAt</code> properties being NULL, or a <code>Cannot insert the value NULL into column</code> error (especially if your seed data expects the database IDs to be auto generated).</p>
<p>There are two things going on here which cause this - bear with me as it gets a bit crazy! The <code>Microsoft.WindowsAzure.Mobile.Service.ServiceConfig.Initialize()</code> method called from our scaffolded <code>WebApiConfig.Register()</code> method injects it's own SQL rewriting method into EntityFramework using the <code>Microsoft.WindowsAzure.Mobile.Service.Config.EntityExtensionConfig</code> and <code>Microsoft.WindowsAzure.Mobile.Service.Tables.EntityTableSqlGenerator</code> classes included with the backend libraries. This SQL generator performs some functionality behind the scenes which prevent the above errors occuring, like configuring autogenerated Guids and DateTimes for the <code>EntityData</code> properties marked with <code>TableColumnType.Id</code> and <code>TableColumnType.CreatedAt</code> attributes, and force disabling index clustering on the primary key if you have an entity property marked with <code>TableColumnType.CreatedAt</code> (all defaults if your data models inherit from <code>EntityData</code>).</p>
<p>If your test doesn't call into a method from <code>Microsoft.WindowsAzure.Mobile.Service.Entity</code> or <code>Microsoft.WindowsAzure.Mobile.Service.Entity.Tables</code> assemblies which both contain <code>[assembly: ExtensionConfigProvider(typeof (EntityExtensionConfig))]</code> in their AssemblyInfo.cs files, you might not load those assemblies into your test project app domain - my initial approach to this involved the controller handling the initialisation in a different way, which meant the test never touched those assemblies.</p>
<p>Unfortunately, the SQL generator is injected by scanning your loaded assemblies for the attribute, which is never an issue for your main API project - see <code>internal static void InitializeExtensions(_Assembly[] loadedAssemblies, HttpConfiguration config, ContainerBuilder containerBuilder)</code> within <code>Microsoft.WindowsAzure.Mobile.Service.ConfigBuilder</code> for how this has been implemented. If you're having this problem, try adding the above attribute to your test AssemblyInfo.cs file yourself.</p>
<h2>Wrapping it up</h2>
<p>I recommend that if using migrations, when running in a test you should configure your seed class to to fully drop and recreate the database each time otherwise it's easy to miss configuration changes that will break the backend down the track.</p>
<p>I've created a base class for my controllers and for my controller tests to add support for this as well as simplify our controllers and tests:</p>
<p><script src="https://gist.github.com/MattDavies/11370025.js"></script></p>
<p>Usage looks like this:</p>
<p><script src="https://gist.github.com/MattDavies/11370123.js"></script></p>
